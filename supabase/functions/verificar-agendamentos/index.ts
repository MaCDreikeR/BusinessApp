// Edge Function para verificar agendamentos e criar comandas automaticamente
// Executa a cada 5 minutos via GitHub Actions

import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

serve(async (req) => {
  try {
    console.log('üîç Iniciando verifica√ß√£o de agendamentos...')

    // Cliente Supabase com permiss√µes de servi√ßo (service_role_key)
    const supabaseUrl = Deno.env.get('SUPABASE_URL') ?? ''
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''

    if (!supabaseUrl || !supabaseServiceKey) {
      throw new Error('Vari√°veis de ambiente n√£o configuradas')
    }

    const supabase = createClient(supabaseUrl, supabaseServiceKey)

    // Janela de tempo: -10min a +10min do hor√°rio atual (aumentado para evitar perder agendamentos)
    const agora = new Date()
    const dezMinutosAntes = new Date(agora.getTime() - 10 * 60000)
    const dezMinutosDepois = new Date(agora.getTime() + 10 * 60000)

    console.log(`‚è∞ Hor√°rio atual: ${agora.toISOString()}`)
    console.log(`‚è∞ Verificando agendamentos entre ${dezMinutosAntes.toISOString()} e ${dezMinutosDepois.toISOString()}`)

    // Buscar agendamentos que est√£o iniciando
    const { data: agendamentos, error: agendamentosError } = await supabase
      .from('agendamentos')
      .select('id, cliente, data_hora, servicos, status, usuario_id, estabelecimento_id, criar_comanda_automatica')
      .gte('data_hora', dezMinutosAntes.toISOString())
      .lte('data_hora', dezMinutosDepois.toISOString())
      .in('status', ['agendado', 'confirmado'])
      .eq('criar_comanda_automatica', true)

    if (agendamentosError) {
      console.error('‚ùå Erro ao buscar agendamentos:', agendamentosError)
      throw agendamentosError
    }

    console.log(`üìã Encontrados ${agendamentos?.length || 0} agendamentos`)
    
    if (agendamentos && agendamentos.length > 0) {
      console.log('üìù Agendamentos encontrados:', JSON.stringify(agendamentos, null, 2))
    }

    let comandasCriadas = 0
    let comandasExistentes = 0
    let erros = 0

    // Processar cada agendamento
    for (const agendamento of agendamentos || []) {
      try {
        console.log(`\nüë§ Processando agendamento de ${agendamento.cliente}...`)
        console.log(`üìÖ Data/hora do agendamento: ${agendamento.data_hora}`)
        console.log(`üìä Status: ${agendamento.status}`)
        console.log(`üè¢ Estabelecimento: ${agendamento.estabelecimento_id}`)

        // Verificar se j√° existe comanda aberta para este cliente hoje
        const inicioDoDia = new Date()
        inicioDoDia.setHours(0, 0, 0, 0)

        const { data: comandaExistente } = await supabase
          .from('comandas')
          .select('id')
          .eq('cliente_nome', agendamento.cliente)
          .eq('estabelecimento_id', agendamento.estabelecimento_id)
          .eq('status', 'aberta')
          .gte('data_abertura', inicioDoDia.toISOString())
          .maybeSingle()

        if (comandaExistente) {
          console.log(`‚úÖ Comanda j√° existe para ${agendamento.cliente} (ID: ${comandaExistente.id})`)
          comandasExistentes++
          continue
        }

        // Buscar cliente_id (obrigat√≥rio para criar comanda)
        const { data: clienteData, error: clienteError } = await supabase
          .from('clientes')
          .select('id')
          .ilike('nome', agendamento.cliente)
          .eq('estabelecimento_id', agendamento.estabelecimento_id)
          .maybeSingle()

        if (clienteError || !clienteData) {
          console.log(`‚ö†Ô∏è Cliente n√£o encontrado: ${agendamento.cliente}`)
          erros++
          continue
        }

        console.log(`üìù Cliente encontrado: ${clienteData.id}`)

        // Parse dos servi√ßos (pode ser string JSON)
        let servicosArray
        if (typeof agendamento.servicos === 'string') {
          servicosArray = JSON.parse(agendamento.servicos)
          console.log(`üîÑ Servi√ßos parseados de string: ${agendamento.servicos}`)
        } else {
          servicosArray = agendamento.servicos
        }
        
        console.log(`üì¶ Servi√ßos a processar:`, JSON.stringify(servicosArray, null, 2))

        // Criar comanda
        const { data: novaComanda, error: comandaError } = await supabase
          .from('comandas')
          .insert({
            cliente_nome: agendamento.cliente,
            cliente_id: clienteData.id,
            estabelecimento_id: agendamento.estabelecimento_id,
            status: 'aberta',
            valor_total: 0,
            created_by_user_id: agendamento.usuario_id,
            data_abertura: new Date().toISOString(),
          })
          .select()
          .single()

        if (comandaError) {
          console.error(`‚ùå Erro ao criar comanda:`, comandaError)
          erros++
          continue
        }

        console.log(`‚úÖ Comanda criada: ${novaComanda.id}`)

        // Adicionar itens (servi√ßos) √† comanda
        const itens = servicosArray.map((servico: any) => ({
          comanda_id: novaComanda.id,
          tipo: 'servico',
          nome: servico.nome,
          preco_unitario: parseFloat(servico.preco),
          preco: parseFloat(servico.preco),
          quantidade: 1,
          preco_total: parseFloat(servico.preco),
          estabelecimento_id: agendamento.estabelecimento_id,
        }))

        console.log(`üì¶ Inserindo ${itens.length} itens na comanda...`)

        const { error: itensError } = await supabase
          .from('comandas_itens')
          .insert(itens)

        if (itensError) {
          console.error(`‚ùå Erro ao inserir itens:`, itensError)
          erros++
          continue
        }

        // Calcular e atualizar valor total
        const valorTotal = itens.reduce((sum: number, item: any) => sum + item.preco_total, 0)

        const { error: updateError } = await supabase
          .from('comandas')
          .update({ valor_total: valorTotal })
          .eq('id', novaComanda.id)

        if (updateError) {
          console.error(`‚ùå Erro ao atualizar valor total:`, updateError)
        }

        console.log(`üí∞ Valor total da comanda: R$ ${valorTotal.toFixed(2)}`)
        console.log(`‚úÖ Comanda completa para ${agendamento.cliente}!`)
        
        comandasCriadas++

      } catch (error) {
        console.error(`‚ùå Erro ao processar agendamento:`, error)
        erros++
      }
    }

    // Resposta final
    const resultado = {
      success: true,
      timestamp: new Date().toISOString(),
      estatisticas: {
        agendamentos_encontrados: agendamentos?.length || 0,
        comandas_criadas: comandasCriadas,
        comandas_existentes: comandasExistentes,
        erros: erros,
      }
    }

    console.log('\nüìä Resultado final:', resultado)

    return new Response(
      JSON.stringify(resultado),
      { 
        status: 200,
        headers: { "Content-Type": "application/json" } 
      }
    )

  } catch (error) {
    console.error('‚ùå Erro fatal:', error)
    
    return new Response(
      JSON.stringify({ 
        success: false, 
        error: error.message,
        timestamp: new Date().toISOString()
      }),
      { 
        status: 500, 
        headers: { "Content-Type": "application/json" } 
      }
    )
  }
})
